---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

name: "ðŸ“Š Production Reports"

# yamllint disable-line rule:truthy
on:
  workflow_dispatch:
    inputs:
      debug:
        description: 'Enable debug output'
        required: false
        type: boolean
        default: false
  schedule:
    # Run every day at 7:00 AM UTC
    - cron: "0 7 * * *"

concurrency:
  group: production-reports
  cancel-in-progress: false  # Don't cancel production runs

permissions: {}

jobs:
  verify:
    name: "Verify Configuration"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 5
    outputs:
      matrix: ${{ steps.parse-projects.outputs.matrix }}
      run_timestamp: ${{ steps.metadata.outputs.timestamp }}
      run_id: ${{ steps.metadata.outputs.run_id }}
    steps:
      # Harden the runner used by this workflow
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: "audit"

      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: "Generate run metadata"
        id: metadata
        shell: bash
        run: |
          timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "timestamp=$timestamp" >> "$GITHUB_OUTPUT"
          echo "run_id=${{ github.run_id }}" >> "$GITHUB_OUTPUT"

          {
            echo "## ðŸ“Š Production Report Generation"
            echo ""
            echo "**Started:** $timestamp"
            echo "**Run ID:** ${{ github.run_id }}"
            echo "**Trigger:** ${{ github.event_name }}"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

      - name: "Verify PROJECTS_JSON variable"
        shell: bash
        run: |
          if [ -z "${{ vars.PROJECTS_JSON }}" ]; then
            echo "::error::PROJECTS_JSON variable is not set"
            exit 1
          fi

          echo "âœ… PROJECTS_JSON variable exists"

      - name: "Validate required secrets"
        shell: bash
        env:
          CLASSIC_READ_ONLY_PAT_TOKEN: >-
            ${{ secrets.CLASSIC_READ_ONLY_PAT_TOKEN }}
          GERRIT_REPORTS_PAT_TOKEN: >-
            ${{ secrets.GERRIT_REPORTS_PAT_TOKEN }}
          LF_GERRIT_INFO_MASTER_SSH_KEY: >-
            ${{ secrets.LF_GERRIT_INFO_MASTER_SSH_KEY }}
        # yamllint disable rule:line-length
        run: |
          validation_failed=false

          # SHA1 of empty string - used to detect empty secrets
          EMPTY_SHA1="da39a3ee5e6b4b0d3255bfef95601890afd80709"

          echo "ðŸ” Secrets Validation"
          echo ""

          # Function to compute SHA1 without trailing newline
          compute_sha1() {
            printf "%s" "$1" | sha1sum | awk '{print $1}'
          }

          # Check CLASSIC_READ_ONLY_PAT_TOKEN
          if [ -z "$CLASSIC_READ_ONLY_PAT_TOKEN" ]; then
            echo "::error::CLASSIC_READ_ONLY_PAT_TOKEN secret is not set"
            echo "âŒ CLASSIC_READ_ONLY_PAT_TOKEN: MISSING"
            validation_failed=true
          else
            token_sha1=$(compute_sha1 "$CLASSIC_READ_ONLY_PAT_TOKEN")
            if [ "$token_sha1" = "$EMPTY_SHA1" ]; then
              echo "::error::CLASSIC_READ_ONLY_PAT_TOKEN is empty"
              echo "âŒ CLASSIC_READ_ONLY_PAT_TOKEN: EMPTY"
              validation_failed=true
            else
              echo "âœ… CLASSIC_READ_ONLY_PAT_TOKEN: $token_sha1"
            fi
          fi

          # Check GERRIT_REPORTS_PAT_TOKEN
          if [ -z "$GERRIT_REPORTS_PAT_TOKEN" ]; then
            echo "::error::GERRIT_REPORTS_PAT_TOKEN secret is not set"
            echo "âŒ GERRIT_REPORTS_PAT_TOKEN: MISSING"
            validation_failed=true
          else
            gerrit_token_sha1=$(compute_sha1 "$GERRIT_REPORTS_PAT_TOKEN")
            if [ "$gerrit_token_sha1" = "$EMPTY_SHA1" ]; then
              echo "::error::GERRIT_REPORTS_PAT_TOKEN is empty"
              echo "âŒ GERRIT_REPORTS_PAT_TOKEN: EMPTY"
              validation_failed=true
            else
              echo "âœ… GERRIT_REPORTS_PAT_TOKEN: $gerrit_token_sha1"
            fi
          fi

          # Check LF_GERRIT_INFO_MASTER_SSH_KEY (warning only)
          if [ -z "$LF_GERRIT_INFO_MASTER_SSH_KEY" ]; then
            echo "::warning::LF_GERRIT_INFO_MASTER_SSH_KEY secret not set"
            echo "âš ï¸  LF_GERRIT_INFO_MASTER_SSH_KEY: MISSING (HTTPS fallback)"
          else
            ssh_key_sha1=$(compute_sha1 "$LF_GERRIT_INFO_MASTER_SSH_KEY")
            if [ "$ssh_key_sha1" = "$EMPTY_SHA1" ]; then
              echo "::warning::LF_GERRIT_INFO_MASTER_SSH_KEY is empty"
              echo "âš ï¸  LF_GERRIT_INFO_MASTER_SSH_KEY: EMPTY (HTTPS fallback)"
            else
              echo "âœ… LF_GERRIT_INFO_MASTER_SSH_KEY: $ssh_key_sha1"
            fi
          fi

          # Write summary
          {
            echo "### ðŸ” Secrets Validation"
            echo ""
            if [ -n "$CLASSIC_READ_ONLY_PAT_TOKEN" ] && [ "${token_sha1:-$EMPTY_SHA1}" != "$EMPTY_SHA1" ]; then
              echo "- âœ… **CLASSIC_READ_ONLY_PAT_TOKEN:** \`${token_sha1}\`"
            else
              echo "- âŒ **CLASSIC_READ_ONLY_PAT_TOKEN:** MISSING or EMPTY"
            fi

            if [ -n "$GERRIT_REPORTS_PAT_TOKEN" ] && [ "${gerrit_token_sha1:-$EMPTY_SHA1}" != "$EMPTY_SHA1" ]; then
              echo "- âœ… **GERRIT_REPORTS_PAT_TOKEN:** \`${gerrit_token_sha1}\`"
            else
              echo "- âŒ **GERRIT_REPORTS_PAT_TOKEN:** MISSING or EMPTY"
            fi

            if [ -n "$LF_GERRIT_INFO_MASTER_SSH_KEY" ] && [ "${ssh_key_sha1:-$EMPTY_SHA1}" != "$EMPTY_SHA1" ]; then
              echo "- âœ… **LF_GERRIT_INFO_MASTER_SSH_KEY:** \`${ssh_key_sha1}\`"
            else
              echo "- âš ï¸ **LF_GERRIT_INFO_MASTER_SSH_KEY:** MISSING or EMPTY (HTTPS fallback)"
            fi
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "$validation_failed" = true ]; then
            echo "::error::Secret validation failed"
            exit 1
          fi

          echo ""
          echo "âœ… All required secrets validated"
        # yamllint enable rule:line-length

      - name: "Parse and validate PROJECTS_JSON"
        id: parse-projects
        shell: bash
        run: |
          projects_json='${{ vars.PROJECTS_JSON }}'

          # Validate JSON syntax
          if ! echo "$projects_json" | jq . > /dev/null 2>&1; then
            echo "::error::PROJECTS_JSON contains invalid JSON"
            exit 1
          fi

          # Validate structure
          if ! echo "$projects_json" | jq -e 'type == "array"' > /dev/null; then
            echo "::error::PROJECTS_JSON must be an array"
            exit 1
          fi

          # Validate required fields
          if ! echo "$projects_json" | \
            jq -e 'all(.project and .gerrit and .slug)' > /dev/null; then
            echo "::error::Each project must have 'project', 'gerrit',"
            echo "'slug' fields"
            exit 1
          fi

          project_count=$(echo "$projects_json" | jq '. | length')
          echo "âœ… Found $project_count project(s) to process"

          # Create matrix
          matrix=$(echo "$projects_json" | jq -c '{include: .}')
          echo "matrix=$matrix" >> "$GITHUB_OUTPUT"

          {
            echo "### Projects to Process"
            echo ""
            echo "**Total projects:** $project_count"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
          echo "$projects_json" | \
            jq -r '.[] | "- **\(.project):** `\(.gerrit)` [\(.slug)]"' >> \
            "$GITHUB_STEP_SUMMARY"

  analyze:
    name: "${{ matrix.project }}"
    needs: verify
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 90
    strategy:
      fail-fast: false
      max-parallel: 4
      matrix: ${{ fromJSON(needs.verify.outputs.matrix) }}
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: "audit"

      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: "Clone Gerrit repositories for ${{ matrix.project }}"
        # yamllint disable-line rule:line-length
        uses: lfreleng-actions/gerrit-clone-action@80b7e603ec8497cc00346d5dec9fae0f346b0548 # v0.1.9
        id: clone
        continue-on-error: true
        with:
          host: ${{ matrix.gerrit }}
          path-prefix: "./${{ matrix.gerrit }}"
          skip-archived: "true"
          threads: "4"
          clone-timeout: "600"
          retry-attempts: "5"
          retry-base-delay: "3.0"
          retry-max-delay: "60.0"
          use-https: "true"
          move-conflicting: "true"

      - name: "Check clone status"
        shell: bash
        # yamllint disable rule:line-length
        run: |
          if [ "${{ steps.clone.outcome }}" != "success" ]; then
            echo "::warning::Failed to clone Gerrit repositories for ${{ matrix.project }}"
            echo "::warning::Gerrit server may be unavailable or decommissioned"
            echo "CLONE_FAILED=true" >> "$GITHUB_ENV"
            # Create empty directory structure so subsequent steps don't fail
            mkdir -p "./${{ matrix.gerrit }}"
          else
            echo "âœ… Successfully cloned Gerrit repositories"
            echo "CLONE_FAILED=false" >> "$GITHUB_ENV"
          fi
        # yamllint enable rule:line-length

      - name: "Clone info-master repository"
        shell: bash
        run: |
          echo "ðŸ”— Cloning info-master repository via HTTPS"

          https_url="https://gerrit.linuxfoundation.org/infra/releng/info-master"

          git clone "$https_url" ./info-master
          echo "âœ… Cloned via HTTPS"

          echo "ðŸ“‚ Info-master contents:"
          find ./info-master -maxdepth 2 -type f -name "*.yaml" | head -5

      - name: "Install uv"
        # yamllint disable-line rule:line-length
        uses: astral-sh/setup-uv@85856786d1ce8acfbcc2f13a5f3fbd6b938f9f41 # v7.1.2

      - name: "Set up Python"
        # yamllint disable-line rule:line-length
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: "3.11"

      - name: "Install dependencies"
        shell: bash
        run: uv sync --all-extras

      - name: "Generate reports for ${{ matrix.project }}"
        if: env.CLONE_FAILED != 'true'
        shell: bash
        env:
          JENKINS_HOST: ${{ matrix.jenkins }}
          # yamllint disable-line rule:line-length
          CLASSIC_READ_ONLY_PAT_TOKEN: ${{ secrets.CLASSIC_READ_ONLY_PAT_TOKEN }}
          GITHUB_ORG: ${{ matrix.github }}
          SSH_AVAILABLE: ${{ env.SSH_AVAILABLE }}
        # yamllint disable rule:line-length
        run: |
          project="${{ matrix.project }}"
          echo "ðŸ“Š Generating reports for $project"

          if [ -n "$JENKINS_HOST" ]; then
            echo "ðŸ”§ Jenkins: $JENKINS_HOST"
          else
            echo "â„¹ï¸ Jenkins integration disabled"
          fi

          if [ -n "$CLASSIC_READ_ONLY_PAT_TOKEN" ]; then
            echo "ðŸ”§ GitHub API integration enabled"
            echo "ðŸ” Using token environment variable: CLASSIC_READ_ONLY_PAT_TOKEN"
            # Debug token format (show prefix only for security)
            token_prefix="${CLASSIC_READ_ONLY_PAT_TOKEN:0:10}"
            token_length="${#CLASSIC_READ_ONLY_PAT_TOKEN}"
            echo "ðŸ” Token prefix: ${token_prefix}..."
            echo "ðŸ” Token length: ${token_length} characters"
            # Check for whitespace
            if [[ "$CLASSIC_READ_ONLY_PAT_TOKEN" =~ [[:space:]] ]]; then
              echo "âš ï¸  WARNING: Token contains whitespace characters!"
              # Try to trim whitespace
              trimmed_token=""
              trimmed_token=$(echo "$CLASSIC_READ_ONLY_PAT_TOKEN" | tr -d '[:space:]')
              export CLASSIC_READ_ONLY_PAT_TOKEN="$trimmed_token"
              echo "ðŸ”§ Token trimmed, new length: ${#CLASSIC_READ_ONLY_PAT_TOKEN}"
            fi

            # Verify token is accessible in environment for Python
            echo "ðŸ” Environment variable CLASSIC_READ_ONLY_PAT_TOKEN is set"

            # Test GitHub API access directly
            echo "ðŸ” Testing GitHub API access..."
            response=""
            response=$(curl -s -H "Authorization: Bearer ${CLASSIC_READ_ONLY_PAT_TOKEN}" \
              "https://api.github.com/user" | jq -r '.login // .message // "ERROR"')
            echo "ðŸ” GitHub API test response: ${response}"
          else
            echo "âš ï¸ GitHub API integration disabled - CLASSIC_READ_ONLY_PAT_TOKEN not set"
          fi

          if [ -n "$GITHUB_ORG" ]; then
            echo "ðŸ” GITHUB_ORG environment variable: ${GITHUB_ORG}"
          else
            echo "ðŸ” GITHUB_ORG environment variable: NOT SET (will auto-derive)"
          fi

          echo "ðŸ“ Running command with --github-token-env CLASSIC_READ_ONLY_PAT_TOKEN"
          echo "ðŸ“ Verifying environment variable is set:"
          if [ -n "$CLASSIC_READ_ONLY_PAT_TOKEN" ]; then
            echo "âœ… CLASSIC_READ_ONLY_PAT_TOKEN is available to command"
          else
            echo "âŒ CLASSIC_READ_ONLY_PAT_TOKEN is NOT available to command"
          fi

          uv run gerrit-reporting-tool generate \
            --project "$project" \
            --repos-path "./${{ matrix.gerrit }}" \
            --output-dir "./reports" \
            --github-token-env CLASSIC_READ_ONLY_PAT_TOKEN \
            --verbose

          echo "âœ… Reports generated for $project"
        # yamllint enable rule:line-length

      - name: "Report skipped due to clone failure"
        if: env.CLONE_FAILED == 'true'
        shell: bash
        # yamllint disable rule:line-length
        run: |
          project="${{ matrix.project }}"
          echo "âš ï¸ Skipping report generation for $project due to Gerrit clone failure"
          echo "::warning::Report generation skipped for $project - Gerrit server unavailable"

          # Create minimal metadata to indicate failure
          mkdir -p "./reports/$project"
          cat > "./reports/$project/metadata.json" <<EOF
          {
            "project": "$project",
            "status": "failed",
            "reason": "Gerrit server unavailable or decommissioned",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "gerrit_host": "${{ matrix.gerrit }}"
          }
          EOF
        # yamllint enable rule:line-length

      - name: "Create report metadata"
        shell: bash
        run: |
          project="${{ matrix.project }}"
          report_dir="./reports/$project"

          if [ ! -d "$report_dir" ]; then
            echo "::error::Report directory not found: $report_dir"
            exit 1
          fi

          # Create metadata file
          cat > "$report_dir/metadata.json" <<EOF
          {
            "project": "$project",
            "slug": "${{ matrix.slug }}",
            "gerrit_server": "${{ matrix.gerrit }}",
            "jenkins_server": "${{ matrix.jenkins }}",
            "github_org": "${{ matrix.github }}",
            "generated_at": "${{ needs.verify.outputs.run_timestamp }}",
            "workflow_run_id": "${{ github.run_id }}",
            "workflow_run_number": "${{ github.run_number }}",
            "workflow_run_attempt": "${{ github.run_attempt }}",
            "git_sha": "${{ github.sha }}",
            "git_ref": "${{ github.ref }}",
            "environment": "production"
          }
          EOF

          echo "âœ… Metadata created"

      - name: "Copy raw data files to temp directory"
        if: always()
        shell: bash
        run: |
          # Create temp directory for raw data files
          mkdir -p ./temp-raw-data-${{ matrix.slug }}

          # Copy JSON files to temp directory (flattening the structure)
          project="${{ matrix.project }}"
          if [ -f "./reports/$project/report_raw.json" ]; then
            cp "./reports/$project/report_raw.json" \
              ./temp-raw-data-${{ matrix.slug }}/
          fi
          if [ -f "./reports/$project/config_resolved.json" ]; then
            cp "./reports/$project/config_resolved.json" \
              ./temp-raw-data-${{ matrix.slug }}/
          fi
          if [ -f "./reports/$project/metadata.json" ]; then
            cp "./reports/$project/metadata.json" \
              ./temp-raw-data-${{ matrix.slug }}/
          fi

          echo "Raw data files prepared for upload"

      - name: "Upload raw data artifacts"
        if: always()
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: raw-data-${{ matrix.slug }}
          path: ./temp-raw-data-${{ matrix.slug }}/
          retention-days: 90
          if-no-files-found: warn
          compression-level: 9

      - name: "Upload report artifacts"
        if: always()
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: reports-${{ matrix.slug }}
          path: ./reports/${{ matrix.project }}/
          retention-days: 90
          if-no-files-found: warn
          compression-level: 6

      - name: "Upload clone manifest"
        if: always()
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: clone-manifest-${{ matrix.slug }}
          path: "./${{ matrix.gerrit }}/clone-manifest.json"
          retention-days: 90
          if-no-files-found: warn

      - name: "Upload clone log"
        if: always()
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: clone-log-${{ matrix.slug }}
          path: "./${{ matrix.gerrit }}.log"
          retention-days: 90
          if-no-files-found: warn

  publish:
    name: "Publish GitHub Pages"
    needs: [verify, analyze]
    if: always() && needs.verify.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write
    timeout-minutes: 20
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: "audit"

      - name: "Checkout main branch for scripts"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Copy script from main branch"
        shell: bash
        run: |
          mkdir -p /tmp/main-scripts
          cp .github/scripts/generate-index.sh /tmp/main-scripts/
          chmod +x /tmp/main-scripts/generate-index.sh
          echo "âœ… Copied generate-index.sh from main branch"

      - name: "Checkout gh-pages branch"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: gh-pages
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Download all report artifacts"
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          pattern: reports-*
          path: ./downloaded-reports
        continue-on-error: true

      - name: "Prepare production reports at root"
        shell: bash
        run: |
          echo "ðŸ“¦ Preparing production reports at root level"

          # Process each downloaded report
          report_count=0
          for artifact_dir in ./downloaded-reports/reports-*
          do
            if [ ! -d "$artifact_dir" ]; then
              continue
            fi

            # Extract slug from artifact directory name (reports-{slug})
            slug=$(basename "$artifact_dir" | sed 's/^reports-//')

            echo "Processing artifact: reports-$slug"

            # Create project directory at root level
            target_dir="$slug"
            mkdir -p "$target_dir"

            # Copy all report files
            if [ -f "$artifact_dir/report.html" ]; then
              cp "$artifact_dir/report.html" "$target_dir/"
            fi

            if [ -f "$artifact_dir/report_raw.json" ]; then
              cp "$artifact_dir/report_raw.json" "$target_dir/"
            fi

            if [ -f "$artifact_dir/report.md" ]; then
              cp "$artifact_dir/report.md" "$target_dir/"
            fi

            if [ -f "$artifact_dir/metadata.json" ]; then
              cp "$artifact_dir/metadata.json" "$target_dir/"
            fi

            report_count=$((report_count + 1))
            echo "  âœ… Prepared $slug"
          done

          echo "REPORT_COUNT=$report_count" >> "$GITHUB_ENV"
          echo "âœ… Prepared $report_count project report(s) at root"

      - name: "Generate index page"
        shell: bash
        run: |
          # Create .nojekyll to disable Jekyll processing
          touch .nojekyll
          echo "âœ… Created .nojekyll file"

          # Generate index at root (pass "." as directory)
          bash /tmp/main-scripts/generate-index.sh . production

      - name: "Commit and push changes"
        shell: bash
        run: |
          git config user.name "lf-releng-reports-bot"
          git config user.email "lf-releng+reports-bot@linuxfoundation.org"

          # Add all project directories and index
          git add index.html || true
          git add .nojekyll || true

          # Add all project report directories (exclude previews/)
          for project_dir in */; do
            # Skip previews and non-report directories
            if [ -d "$project_dir" ] && \
               [ "$project_dir" != "previews/" ] && \
               [ -f "$project_dir/report.html" ]; then
              echo "Adding $project_dir"
              git add "$project_dir"
            fi
          done

          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          cat > /tmp/commit-msg.txt <<EOF
          chore: update production reports (run ${{ github.run_id }})

          Generated: ${{ needs.verify.outputs.run_timestamp }}
          Reports: ${{ env.REPORT_COUNT }} project(s)
          Run: ${{ github.run_id }}
          EOF

          git commit -F /tmp/commit-msg.txt
          git push origin gh-pages

          echo "âœ… Published to GitHub Pages"

          {
            echo "## ðŸ“¤ Reports Published"
            echo ""
            echo "**Reports published:** ${{ env.REPORT_COUNT }}"
            echo "**Branch:** gh-pages"
            echo "**Path:** (root)"
            echo ""
            echo "### ðŸŒ View Reports"
            echo ""
            echo "Reports will be available at:"
            owner="${{ github.repository_owner }}"
            repo="${{ github.event.repository.name }}"
            echo "https://${owner}.github.io/${repo}/"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

  copy-to-gerrit-reports:
    name: "Transfer/Copy Artifacts"
    needs: [verify, analyze]
    if: |
      always() &&
      needs.verify.result == 'success' &&
      (github.event_name == 'schedule' ||
       github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 15
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: "audit"

      - name: "Checkout repository for scripts"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: "Download all artifacts"
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          path: ./downloaded-artifacts
          merge-multiple: false
        continue-on-error: false

      - name: "Generate date folder name"
        id: date
        shell: bash
        run: |
          DATE_FOLDER=$(date -u +%Y-%m-%d)
          echo "folder=${DATE_FOLDER}" >> "$GITHUB_OUTPUT"
          echo "Date folder: ${DATE_FOLDER}"

      - name: "Debug: Show downloaded artifacts"
        shell: bash
        run: |
          echo "=== Downloaded artifacts structure ==="
          if [ -d "./downloaded-artifacts" ]; then
            find ./downloaded-artifacts -maxdepth 2 -type d | sort
            echo ""
            echo "=== Total artifact count ==="
            find ./downloaded-artifacts -mindepth 1 -maxdepth 1 -type d | wc -l
            echo ""
            echo "=== Total file count ==="
            find ./downloaded-artifacts -type f | wc -l
          else
            echo "ERROR: ./downloaded-artifacts directory does not exist!"
            exit 1
          fi

      - name: "Copy artifacts to gerrit-reports repository"
        shell: bash
        env:
          GERRIT_REPORTS_PAT_TOKEN: ${{ secrets.GERRIT_REPORTS_PAT_TOKEN }}
        run: |
          chmod +x .github/scripts/copy-artifacts-simple.sh
          .github/scripts/copy-artifacts-simple.sh \
            "${{ steps.date.outputs.folder }}" \
            "${{ github.run_id }}" \
            "./downloaded-artifacts" \
            "$GERRIT_REPORTS_PAT_TOKEN"

      - name: "Generate job summary"
        if: always()
        shell: bash
        # yamllint disable rule:line-length
        run: |
          {
            echo "## ðŸ“¦ Artifacts Transferred"
            echo ""
            echo "**Date Folder:** ${{ steps.date.outputs.folder }}"
            echo "**Workflow Run:** ${{ github.run_id }}"
            echo "**Target Repository:** modeseven-lfit/gerrit-reports"
            echo "**Status:** ${{ job.status }}"
            echo ""
            echo "### ðŸ”— View in Repository"
            echo ""
            echo "https://github.com/modeseven-lfit/gerrit-reports/tree/main/data/artifacts/${{ steps.date.outputs.folder }}"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
      # yamllint enable rule:line-length

  summary:
    name: "Workflow Summary"
    needs: [verify, analyze, publish, copy-to-gerrit-reports]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: "audit"

      - name: "Generate workflow summary"
        shell: bash
        run: |
          # Helper function to convert result to emoji
          result_emoji() {
            case "$1" in
              success) echo "âœ…" ;;
              failure) echo "âŒ" ;;
              cancelled) echo "âš ï¸" ;;
              skipped) echo "â­ï¸" ;;
              *) echo "â“" ;;
            esac
          }

          # Parse projects JSON to get slugs
          projects_json='${{ vars.PROJECTS_JSON }}'

          {
            echo "## ðŸ“Š Production Report Generation Complete"
            echo ""
            echo "**Completed:** $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "**Status:** ${{ needs.publish.result }}"
            echo ""
            echo "### Job Results"
            echo ""
            echo "- **Verify:** $(result_emoji '${{ needs.verify.result }}')"
            echo "- **Analyze:** $(result_emoji \
              '${{ needs.analyze.result }}')"
            echo "- **Publish:** $(result_emoji \
              '${{ needs.publish.result }}')"
            echo "- **Copy:** $(result_emoji \
              '${{ needs.copy-to-gerrit-reports.result }}')"
            echo ""

            # Add links to project reports if publish succeeded
            if [ "${{ needs.publish.result }}" = "success" ]; then
              echo "### ðŸ“‘ Project Reports"
              echo ""
              owner="${{ github.repository_owner }}"
              repo="${{ github.event.repository.name }}"
              base_url="https://${owner}.github.io/${repo}"

              # Parse and display each project with link
              echo "$projects_json" | \
                jq -r '.[] | "\(.project)|\(.slug)"' | \
                while IFS='|' read -r project_name slug; do
                report_url="${base_url}/${slug}/report.html"
                data_url="${base_url}/${slug}/report_raw.json"
                echo "- **${project_name}:** [View Report](${report_url})" \
                  "â€¢ [Raw Data](${data_url})"
              done
              echo ""
              echo "**Index:** [View All Reports](${base_url}/)"
              echo ""
            fi
          } >> "$GITHUB_STEP_SUMMARY"
